from __future__ import annotations\nimport re\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Any\n\n@dataclass\nclass Statement:\n    raw: str\n    kind: str  # \"added\", \"removed\", \"unchanged\"\n    index: int\n    parsed: Dict[str, Any]\n\n@dataclass\nclass MethodIR:\n    name: str\n    ret_type: str\n    parameters: List[Dict[str, str]]  # [{\"name\": \"...\", \"type\": \"...\"}]\n    stmts: List[Statement]\n\nDECL_TYPES = r\"(?:int|double|float|long|short|byte|char|boolean|bool)\"\n\ndef _clean_body(body: str) -> List[str]:\n    body = body.replace(\"{\", \" \").replace(\"}\", \" \")\n    body = body.replace(\";\", \";\\n\")\n    lines = [ln.strip() for ln in body.splitlines() if ln.strip()]\n    return lines\n\ndef parse_method(text: str) -> MethodIR:\n    m = re.search(r\"(?P<ret>\\w+)\\s+(?P<name>\\w+)\\s*\\((?P<params>[^)]*)\\)\\s*\\{(?P<body>.*)\\}\\s*$\", text.strip(), flags=re.DOTALL)\n    if not m:\n        raise ValueError(\"Failed to parse method signature/body\")\n    ret = m.group(\"ret\")\n    name = m.group(\"name\")\n    params_raw = m.group(\"params\").strip()\n    body_raw = m.group(\"body\")\n\n    params = []\n    if params_raw:\n        for piece in params_raw.split(\",\"):\n            piece = piece.strip()\n            pm = re.match(rf\"({DECL_TYPES})\\s+([A-Za-z_]\\w*)\", piece)\n            if pm:\n                params.append({\"type\": pm.group(1), \"name\": pm.group(2)})\n            else:\n                toks = piece.split()\n                if len(toks) == 2:\n                    params.append({\"type\": toks[0], \"name\": toks[1]})\n                elif len(toks) == 1:\n                    params.append({\"type\": \"unknown\", \"name\": toks[0]})\n                else:\n                    params.append({\"type\": \"unknown\", \"name\": piece})\n\n    lines = _clean_body(body_raw)\n    stmts: List[Statement] = []\n    idx = 0\n    for ln in lines:\n        tag = \"unchanged\"\n        if ln.startswith(\"+ \"):\n            tag = \"added\"\n            ln = ln[2:].strip()\n        elif ln.startswith(\"- \"):\n            tag = \"removed\"\n            ln = ln[2:].strip()\n        parsed = _parse_statement(ln)\n        stmts.append(Statement(raw=ln, kind=tag, index=idx, parsed=parsed))\n        idx += 1\n    return MethodIR(name=name, ret_type=ret, parameters=params, stmts=stmts)\n\ndef _parse_statement(ln: str) -> Dict[str, Any]:\n    m_if = re.match(r\"if\\s*\\((?P<cond>[^)]*)\\)\\s*(?P<body>.+);$\", ln)\n    if m_if:\n        return {\n            \"type\": \"if\",\n            \"cond\": m_if.group(\"cond\").strip(),\n            \"body\": _parse_statement(m_if.group(\"body\").strip()+\";\")\n        }\n    m_ret = re.match(r\"return\\s+(?P<expr>.+);$\", ln)\n    if m_ret:\n        return {\"type\": \"return\", \"expr\": m_ret.group(\"expr\").strip()}\n    m_decl_assign = re.match(rf\"(?P<type>{DECL_TYPES})\\s+(?P<name>[A-Za-z_]\\w*)\\s*=\\s*(?P<rhs>.+);$\", ln)\n    if m_decl_assign:\n        return {\n            \"type\": \"assign\",\n            \"decl_type\": m_decl_assign.group(\"type\"),\n            \"lhs\": m_decl_assign.group(\"name\"),\n            \"rhs\": _parse_rhs(m_decl_assign.group(\"rhs\").strip())\n        }\n    m_assign = re.match(r\"(?P<name>[A-Za-z_]\\w*)\\s*=\\s*(?P<rhs>.+);$\", ln)\n    if m_assign:\n        return {\n            \"type\": \"assign\",\n            \"decl_type\": None,\n            \"lhs\": m_assign.group(\"name\"),\n            \"rhs\": _parse_rhs(m_assign.group(\"rhs\").strip())\n        }\n    return {\"type\": \"unknown\", \"text\": ln}\n\ndef _parse_rhs(rhs: str) -> Dict[str, Any]:\n    m_fun = re.match(r\"(?P<func>[A-Za-z_]\\w*)\\s*\\((?P<args>[^)]*)\\)\\s*$\", rhs)\n    if m_fun:\n        args = [a.strip() for a in m_fun.group(\"args\").split(\",\") if a.strip()]\n        return {\"kind\": \"funcall\", \"func\": m_fun.group(\"func\"), \"args\": args}\n    for op in [\"/\", \"+\"]:\n        m_bin = re.match(rf\"(?P<left>[A-Za-z_]\\w*)\\s*\\{op}\\s*(?P<right>[A-Za-z_]\\w*)\\s*$\", rhs)\n        if m_bin:\n            return {\"kind\": \"binary\", \"op\": op, \"operands\": [m_bin.group(\"left\"), m_bin.group(\"right\")]}\n    return {\"kind\": \"atom\", \"value\": rhs.strip()}\n